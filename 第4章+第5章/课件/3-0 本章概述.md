# 3-0 本章概述

3-1  安装 MySql 数据库

3-2  关系型数据库和非关系型数据库

3-3  mysql 登录，新建用户，分配权限

3-4  mysql  常用的12种数据类型

3-5  mysql 命令状态下数据库，数据表操作

3-6  多种 sql 查询

3-7  安装 Navicat 工具

3-8  搭建 Koa  + TS 初始项目和相关依赖

3-9  思考题：说说添加一级路由的好处

3-10 路由实现——用户二级路由，路由请求实现

3-11 TS应用——解决ctx 不能智能提示 params的问题

3-12  路由加载——手写路由自动加载【避开 TS 中 requireDirectory 底层坑】

3-13 全局异常——搭建 Aop 全局通用异常

3-14  响应处理——响应成功和响应失败精简封装

3-15  重要细节处理——全局异常和响应关联

3-16 日志封装——运用 TS  封装  log4js

3-17 数据库配置封装——综合应用  TS  实现 mySql  配置【方法重载+泛型综合】

3-18  作业——如果 数据库配置或配置项需要更新，如何实现

3-19 数据库连接——TS异步封装数据库连接和通用查询方法

3-20 ORM框架——用 Sequelize 连接 mysql 和 5种 查询

3-21 koa 访问数据库服务器高性能优化——sequelize 数据库连接池

3-22 连接池应用——koa 使用连接池访问 mysql 和感知连接池的存在

3-23 sequelize 底层连接池实现原理

3-24 分层实现——Dao 层封装 sequelize 实现

3-25 作业——用 Dao 层封装 addUser 功能

3-26 分层实现——经常被误用误解的 service 到如何正确理解？

3-27 封层实现——用 Service 封装 sequelize 实现

3-28 sequelize 表关联实现准备——理解 MySql 表外键

3-29 sequelize 表关联实现准备——理解表关联【一对多，多对一】

3-30 sequelize 表关联实现准备——MySql 表左外连接，右外连接

3-31 sequelize 表关联实现——当当书城二级、三级分类 级联查询 实现

3-32 sequelize 多表关联局限性——前端需要获取级联数据，但sequelize返回结果相差太远

3-33 解决 sequelize 多表关联局限性准备

3-34 深度 应用 TS 泛型+高级类型 解决 sequelize 多表关联局限性

3-35 深度 应用 TS 泛型+高级类型 解决 sequelize 多表关联局限性

3-36 深度 应用 TS 泛型+高级类型 构建 前端 真正需要的多表级联数据

3-37 项目架构再升级——模块化管理项目

3-38 装饰器重构路由准备——理解装饰器重构路给大中项目带来的3大优势

3-39 装饰器重构 Koa 路由准备——类装饰器

3-40 装饰器重构 Koa 路由准备——泛型工厂类继承装饰器

3-41 作业——理解泛型工厂类装饰器的其他意义

3-42 装饰器重构 Koa 路由准备——方法装饰器

3-43 装饰器重构 Koa 路由准备——reflect-metadata

3-43 metakey 相同，是否会覆盖？

3-44 TS 装饰器重构 Koa 路由—请求方法装饰器实现

3-45 自动路由重构——为装饰器重构路由自动加载

3-46 TS 装饰器重构 Koa 路由——装饰器 Contoller 实现

3-47 代码进一步优化——响应成功或失败数据封装

3-48 作业：创建当当图书图书表并添加数据

3-49 作业 使用 sequelize 完成图书 model 实现

3-50 作业 使用 sequelize 完成当当图书模糊和分页查询

3- 51 图文，前端高级架构师挑战题—— 举例展示 用 sequelize 事务带来的好处【选做题】

3-52 本章总结